<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Bubble Map — cleaner layout (collision, adjustable forces)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{--accent:#2f80ed;--muted:#9aa6c4;background:#fafbfd}
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--background)}
  body{display:flex;height:100vh}
  #left{width:36%;padding:12px;border-right:1px solid #e6e9f2;box-sizing:border-box;background:#fff;overflow:auto}
  #right{flex:1;position:relative}
  textarea{width:100%;height:52vh;box-sizing:border-box;font-family:ui-monospace,monospace;font-size:13px;padding:8px;border:1px solid #e6e9f2;border-radius:6px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  button{background:var(--accent);color:#fff;border:0;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#fff;color:#333;border:1px solid #dfe7fb}
  label{font-size:13px;color:#333}
  .small{font-size:12px;color:#666}
  .sl{display:flex;align-items:center;gap:8px;margin-top:6px}
  input[type=range]{width:160px}
  #graph{width:100%;height:100%;background:linear-gradient(#fbfdff,#ffffff)}
  .tooltip{position:absolute;padding:6px 8px;background:#222;color:#fff;border-radius:6px;font-size:12px;pointer-events:none;opacity:0;transition:opacity .12s}
</style>
</head>
<body>

<div id="left">
  <h3>Markdown input (heading + cross-links)</h3>
  <small class="small">Cú pháp: Heading `#` … `###### Label {size:NN color:#HEX}` — Cross link: <code>-> Source | Target {color:#HEX}</code></small>
  <textarea id="mdInput"># Trung tâm {size:80 color:#ff6b4a}

##### Sản phẩm A {size:44 color:#4aa7ff}
###### A1 {size:22 color:#ffd36b}
###### A2
###### A3

##### Sản phẩm B {size:44 color:#33d1ff}
###### B1

---
# Cross Links
-> A1 | Sản phẩm B {color:#00ffaa}
  </textarea>

  <div class="controls">
    <button id="renderBtn">Render</button>
    <button id="fitBtn" class="secondary">Fit view</button>
    <button id="toggleLabels" class="secondary">Toggle labels</button>
  </div>

  <div style="margin-top:12px">
    <label class="small">Tuning (nhấn Render sau khi chỉnh)</label>
    <div class="sl"><label>Link dist</label><input id="linkDist" type="range" min="40" max="300" value="120"><span id="linkDistVal">120</span></div>
    <div class="sl"><label>Charge</label><input id="charge" type="range" min="-1200" max="-50" value="-380"><span id="chargeVal">-380</span></div>
    <div class="sl"><label>Collision pad</label><input id="collide" type="range" min="0" max="30" value="7"><span id="collideVal">7</span></div>
    <div class="sl"><label>Label size threshold</label><input id="labelTh" type="range" min="0" max="80" value="22"><span id="labelThVal">22</span></div>
  </div>

  <div style="margin-top:12px">
    <label class="small">Gợi ý hiển thị</label>
    <div class="small" style="margin-top:6px">• Kéo node để điều chỉnh vị trí. Click node để highlight các liên kết và node kề. Hover để xem tooltip. Dùng sliders để điều chỉnh layout.</div>
  </div>
</div>

<div id="right">
  <div id="graph"></div>
  <div id="tooltip" class="tooltip"></div>
</div>

<script>
// ---------- helpers ----------
function parseAttributes(text){
  const res = {};
  if (!text) return res;
  const m = text.match(/\{([^}]*)\}/);
  if (!m) return res;
  const parts = m[1].split(/[,\s]+/).map(s=>s.trim()).filter(Boolean);
  parts.forEach(p=>{
    const [k, ...rest] = p.split(':');
    if (!k) return;
    const v = rest.join(':');
    if (k.toLowerCase() === 'size') {
      const n = Number(v); if (!isNaN(n)) res.size = n;
    } else if (k.toLowerCase() === 'color') {
      res.color = v;
    }
  });
  return res;
}
function randomPastelHex(){
  const r = Math.round(Math.random()*140 + 80);
  const g = Math.round(Math.random()*140 + 80);
  const b = Math.round(Math.random()*140 + 80);
  return '#'+[r,g,b].map(n=>n.toString(16).padStart(2,'0')).join('');
}
function defaultSize(level){
  if (level===1) return 70;
  if (level===2) return 44;
  if (level===3) return 28;
  return 16;
}

// ---------- parse markdown into nodes & links (merge nodes by label) ----------
function parseMarkdown(md){
  const lines = md.split(/\r?\n/).map(l=>l.replace('\u00A0',' ').trim());
  const nodes = new Map();
  const links = [];
  const stack = [];

  for (let raw of lines){
    if (!raw) continue;
    // cross link: -> src | tgt {color:...}
    const cross = raw.match(/^->\s*(.*?)\s*\|\s*(.*?)\s*(\{[^}]*\})?$/);
    if (cross){
      const s = cross[1].trim(), t = cross[2].trim();
      const attrs = parseAttributes(cross[3]||'');
      if (!nodes.has(s)) nodes.set(s, {id:s,label:s,size:null,color:null});
      if (!nodes.has(t)) nodes.set(t, {id:t,label:t,size:null,color:null});
      links.push({ source: s, target: t, color: attrs.color || null, cross: true });
      continue;
    }
    const h = raw.match(/^(#{1,7})\s+(.*)$/);
    if (h){
      const level = h[1].length;
      const rest = h[2].trim();
      const attrs = parseAttributes(rest);
      const label = rest.replace(/\{.*\}/,'').trim();
      if (!nodes.has(label)){
        nodes.set(label, { id:label, label, size: attrs.size || defaultSize(level), color: attrs.color || randomPastelHex(), level });
      } else {
        const cur = nodes.get(label);
        if (attrs.size !== undefined) cur.size = attrs.size;
        if (attrs.color !== undefined) cur.color = attrs.color;
        if (!cur.level) cur.level = level;
      }
      // parent link from nearest smaller level
      while (stack.length && stack[stack.length-1].level >= level) stack.pop();
      if (stack.length){
        const parent = stack[stack.length-1].label;
        links.push({ source: parent, target: label, color: null, cross: false });
      }
      stack.push({ level, label });
    }
  }

  return { nodes: Array.from(nodes.values()), links };
}

// ---------- draw graph ----------
let svg, g, simulation;
let currentHighlighted = null;
const tooltip = document.getElementById('tooltip');

function draw(nodes, links, opts){
  const container = document.getElementById('graph');
  container.innerHTML = '';
  const w = container.clientWidth || window.innerWidth;
  const h = container.clientHeight || window.innerHeight;

  svg = d3.select(container).append('svg').attr('width', w).attr('height', h).style('background','transparent');
  g = svg.append('g');

  // zoom/pan
  const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (e)=> g.attr('transform', e.transform));
  svg.call(zoom);

  // prepare map for simulation links
  const nodeById = new Map(nodes.map(n=>[n.id,n]));
  const simLinks = links.map(l => ({
    source: nodeById.get(l.source) || nodeById.get(l.target) || {id:l.source},
    target: nodeById.get(l.target) || nodeById.get(l.source) || {id:l.target},
    color: l.color || null,
    cross: !!l.cross
  }));

  // link elements
  const linkG = g.append('g').attr('class','links');
  const linkElems = linkG.selectAll('line').data(simLinks).join('line')
    .attr('stroke', d=>d.color || '#d6d6d6')
    .attr('stroke-width', d=> d.cross ? 2.2 : 1.6)
    .attr('opacity',0.9)
    .attr('stroke-linecap','round');

  // node groups
  const nodeG = g.append('g').attr('class','nodes');
  const nodeGroups = nodeG.selectAll('g').data(nodes, d=>d.id).join('g').attr('class','node');

  nodeGroups.append('circle')
    .attr('r', d => d.size)
    .attr('fill', d => d.color)
    .attr('stroke','#222')
    .attr('stroke-width',0.8)
    .style('cursor','pointer');

  nodeGroups.append('text')
    .text(d=>d.label)
    .attr('x', d => Math.max(8, d.size + 7))
    .attr('y', 4)
    .style('font-size','12px')
    .style('pointer-events','none')
    .style('opacity', d => (d.size >= opts.labelThreshold ? 1 : 0)) // hide small labels
    .attr('class','nlabel');

  // adjacency
  const adj = new Map(); nodes.forEach(n=>adj.set(n.id,new Set()));
  simLinks.forEach(l=> { if (l.source && l.target) { adj.get(l.source.id).add(l.target.id); adj.get(l.target.id).add(l.source.id); } });

  // forces
  simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(d=> {
      // base on linkDist slider and node sizes
      const base = opts.linkDist;
      const extra = ((d.source.size || 16) + (d.target.size || 16)) * 0.6;
      return Math.max(base, extra);
    }).strength(0.9))
    .force('charge', d3.forceManyBody().strength(opts.charge))
    .force('center', d3.forceCenter(w/2,h/2))
    .force('collide', d3.forceCollide(d=> (d.size || 12) + opts.collidePad).iterations(2))
    .alphaDecay(0.02)
    .on('tick', ticked);

  function ticked(){
    linkElems
      .attr('x1', d=>d.source.x)
      .attr('y1', d=>d.source.y)
      .attr('x2', d=>d.target.x)
      .attr('y2', d=>d.target.y);

    nodeGroups.attr('transform', d=>`translate(${d.x},${d.y})`);
  }

  // drag (zoom-aware)
  function dragstarted(event,d){
    if (!event.active) simulation.alphaTarget(0.3).restart();
    const pt = d3.zoomTransform(svg.node()).invert(d3.pointer(event, svg.node()));
    d.fx = pt[0]; d.fy = pt[1];
  }
  function dragged(event,d){
    const pt = d3.zoomTransform(svg.node()).invert(d3.pointer(event, svg.node()));
    d.fx = pt[0]; d.fy = pt[1];
  }
  function dragended(event,d){
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null; d.fy = null;
  }
  nodeGroups.call(d3.drag().on('start',dragstarted).on('drag',dragged).on('end',dragended));

  // hover tooltip
  nodeGroups.on('mouseover', (event,d)=>{
    const [mx,my] = d3.pointer(event, document.body);
    tooltip.style.left = (mx+14) + 'px';
    tooltip.style.top = (my+10) + 'px';
    tooltip.style.opacity = 1;
    tooltip.innerHTML = `<strong>${d.label}</strong><br>size: ${d.size}<br>color: ${d.color}`;
    // highlight connected labels temporarily
    d3.select(event.currentTarget).select('circle').attr('stroke-width',2.2);
  }).on('mousemove', (event)=> {
    const [mx,my] = d3.pointer(event, document.body);
    tooltip.style.left = (mx+14) + 'px';
    tooltip.style.top = (my+10) + 'px';
  }).on('mouseout', (event)=> {
    tooltip.style.opacity = 0;
    d3.select(event.currentTarget).select('circle').attr('stroke-width',0.8);
  });

  // click highlight
  nodeGroups.on('click', (event,d) => {
    event.stopPropagation();
    if (currentHighlighted === d.id) { resetHighlight(); currentHighlighted = null; return; }
    currentHighlighted = d.id;
    // highlight links touching d
    linkElems.transition().duration(120)
      .attr('stroke', l => (l.source.id===d.id || l.target.id===d.id) ? (l.color || d.color) : '#eee')
      .attr('stroke-width', l => (l.source.id===d.id || l.target.id===d.id) ? 4 : 1.0)
      .attr('opacity', l => (l.source.id===d.id || l.target.id===d.id) ? 1 : 0.25);
    // highlight nodes neighbors
    nodeGroups.select('circle').transition().duration(120)
      .attr('fill', nd => (nd.id===d.id || adj.get(d.id).has(nd.id)) ? nd.color : '#efefef')
      .attr('opacity', nd => (nd.id===d.id || adj.get(d.id).has(nd.id)) ? 1 : 0.4)
      .attr('stroke-width', nd => nd.id===d.id ? 1.8 : 0.8);
    nodeGroups.select('text').transition().duration(120).style('fill-opacity', nd => (nd.id===d.id || adj.get(d.id).has(nd.id)) ? 1 : 0.35);
  });

  // click background to reset
  svg.on('click', ()=>{ resetHighlight(); currentHighlighted = null; });

  function resetHighlight(){
    linkElems.transition().duration(120).attr('stroke', d=> d.color || '#d6d6d6').attr('stroke-width', d=> d.cross?2.2:1.6).attr('opacity',0.9);
    nodeGroups.select('circle').transition().duration(120).attr('fill', d=>d.color).attr('opacity',1).attr('stroke-width',0.8);
    nodeGroups.select('text').transition().duration(120).style('fill-opacity', d => (d.size >= opts.labelThreshold ? 1 : 0.25));
  }
}

// ---------- UI wiring ----------
const linkDistEl = document.getElementById('linkDist');
const linkDistVal = document.getElementById('linkDistVal');
const chargeEl = document.getElementById('charge');
const chargeVal = document.getElementById('chargeVal');
const collideEl = document.getElementById('collide');
const collideVal = document.getElementById('collideVal');
const labelThEl = document.getElementById('labelTh');
const labelThVal = document.getElementById('labelThVal');
const toggleLabelsBtn = document.getElementById('toggleLabels');
let showLabelsForced = false;

linkDistEl.oninput = ()=> linkDistVal.textContent = linkDistEl.value;
chargeEl.oninput = ()=> chargeVal.textContent = chargeEl.value;
collideEl.oninput = ()=> collideVal.textContent = collideEl.value;
labelThEl.oninput = ()=> labelThVal.textContent = labelThEl.value;

document.getElementById('renderBtn').addEventListener('click', ()=> {
  const md = document.getElementById('mdInput').value;
  const parsed = parseMarkdown(md);
  const opts = {
    linkDist: Number(linkDistEl.value),
    charge: Number(chargeEl.value),
    collidePad: Number(collideEl.value),
    labelThreshold: Number(labelThEl.value)
  };
  draw(parsed.nodes, parsed.links, opts);
});
document.getElementById('fitBtn').addEventListener('click', ()=> {
  const svgEl = d3.select('#graph svg');
  svgEl.transition().duration(400).call(d3.zoom().transform, d3.zoomIdentity);
});
toggleLabelsBtn.addEventListener('click', ()=> {
  showLabelsForced = !showLabelsForced;
  // toggle CSS on labels by re-render (quick approach)
  document.getElementById('renderBtn').click();
});

// auto render initial sample
document.getElementById('renderBtn').click();

</script>
</body>
</html>
